-----------------------------------------ASYNC ACTIONS-----------------------------------------------------------------
- first thing is to decide how to structure the action
- we will create the action and then then I think the actual api call get passed into it
- we will have to rework the state

- we are going the multiple type approach with the actions because it will leave less room for errors
-I am dumb, I should just make the action creators that I have now into async Creators
- normaly an action creator will return an object but with middleware in play it allows us to return functions
- these returned functions will be used to make async calls and will be called by the middleware
- this action creator becomes a thunk

- so the way that they have it is that they have one big asyn function with three smaller funtions running inside of it
- so I think that my smaller action creators that I currently have are going to be the smaller functions that I
will call in my larger async action creator. I will have them be returned and then they can be called by the middleware

- I think I know where things are going now.
- basically we have an action creator that returns a function and inside that function we have some async code run
and then we will pass the results of that code into our normal synchronous action creator.
- so now I will go read up on async programming and promises. we are going to use a promise to make the api call

PROMISES
-the promise object represents the completion or failure of the async operation. its an intermediate state
- the .then() are used for callback functions that will run if the previous operation is successful
-async operations like promises are put into an event queue.which runs after the main thread
- we are going to place our action creator call inside of an .then()method
- so I will create a new promise and
- the promise constructor is used to wrap functions that do not already support promises
- the new promise object takes an executor function as a parameter
- the executor is custom code but it should go like this. executor(resolutionFunc, rejectionFunc)
- so it goes like this, the operation within the executor is asynchronous and provides a callback. the callback
within the executor code.The callback terminates by invoking resolutionFunc. The invocation of resolutionFunc includes
a value parameter. The value is passed back to the tethered PromiseObj. The promiseObj the asynchronous invokes the
.then() associated with it
- right, so we have to write the executor. for the executor is just going to be a callback function. Just so I can see
how things are working out.
- not sure if my implementation works or not. but I have to put in the middleware before I can find out.

--------------------------------------MIDDLESWARE---------------------------------------------------------------------------
-in Redux MiddleWareprovides a third party extension point between dispatching an aciton and the moment it reaches
the reducer
- we are going to monkeypatch the dispatch function. Since the redux store is just a plain object with a few methods
 we just access the dispatch method on the state object and change it
 - the Redux documentation has a lot of info about making your own middleware but for the moment I want to just use
 the recommended redux-thunk

 -I honest just might be doing a whole code redo with some new libraries to make things clean
 - right now I am just going to try and get the thing to work

 WHAT IS A THUNK
- generally thunks are a functional propgramming technique used to delay computation
- the idea is that you return a function that will be called later
- redux-thunk passes two arguments to the think: dispatch and getState.
- now if everything workouts out as planned, this should work as planned
- it didnt go to plan. The problem that I am having right now is that the chill reducer isn't being run
-as i suspected, it is my .then()method that is not working properly. it just isn't being called.
- Think I know what is wrong, I didn't pass any functions into my executor function. This is what is causing the problem.
- the executor by itself has no meaningful return value, it communicates via the side-effect caused by the resolution or
rejectionFunc. the side effect is that the promiseObj becomes settled
-so to solve my problem, the only thing that I need to do is add the function that I am going to call in as a parameter
- the executor has the opportunity to perform some operation and then reflect the operation's outcome. but returning
the call with an invocation or either the rejection/ resolve function.
- we have now got the .then() being called. The problem now is getting the action creator to fire
- actually the chill function is being called. SO the problem must fall to the reducer.the action creator is being
called but it isnt actually changing the state.
- I think that my problem is that I am not dispatching the action with the literal dispatch method

------------------------------------TESTING----------------------------------------------------------------------------------
- I installed es lint and I am starting to configure it a bit
-the rules of test driven development
1)program the tests first
2)Run the tests and watch them fail(red), before you write the code
3)write the minimum amount of code required to make the tests pass(green)
4)refector the code and tests(gold)
5) once the code has passed the tests, it is then time to take a closer look at your code and make it more beautiful

- now we will be testing reducers, since reducers are pure functions that calculate and return data based on their
input arguments. If we can control the input, then we can predict the output
- so es lint is not acctualy a testing framework. It does what is called linting. linting basically analyzes the
codes syntax for errors. It is to make sure that we have proper code formatting. It is not a testing framework
- now we have to install a testing framework
- so I now have jest installed globally so i can run it from anywhere and as a dependency on my project.
- so this is how it would go. you create your file and then you do a module.export of the function
- then you create the test file, called whatever.test.js i beleive the .test is used to tell jest what file to test
- you then import the function with a require(filepath). then follow the required testing function calls.

what is the module.export:
- it seems that it is the way that node exports stuff from one file to another

 what is the require('./filepath')
 - on a side note, I see the commonJS module pattern mentioned everywhere, later when I refactor my code, after I am
 done with the tests. I will have to look into it.
- the require is the way that you import functions(modules) into other files.

- so apparently jest has two important functions. one is called describe, which is used to create a suite of tests
and it, which is used for each test.
- you would use describe to block together several related tests
-the it function is literally the same thing as test function. so the two can be switched out.
- so basically we will import the reducer, give it a fake action and state and then use .expect to say what we
expect the result to be
- so first lets get some tests up and running for the syncronous reducer
- combine Reducers looks like it is just returning an object and I can use dot notation to access the reducers
for the tests
- so the importing funcitons into my test suits is going a little weird with all my spaghetti code. I think its
time to make things modular.
- the problem that I am getting is an import problem and that could be do to the fact that I am running it on node
and node wants to use moduels instead of the normal import statements. So I think If i just import everything
normaly and then run it with jest, then it should all work out ok.
- now I am installing some decencies that are needed for testing in Redux

-with all the importing that I am doing, I think I should just make my code modular now, so that IT doesnt get
worse than it already is.
- well I guess actually I am suppose to do the tests first so that is what I will do.
- first I will import the action creators into my test file.
- so I have installed everything and configured the code, so that jest recognizes the import statements.
- the problem that I am starting to have now is that the I am getting the error that toBe or toEqual is not a function
- I have a theory that this could be the error that gets thrown out when the code is wrong, so I will run it with
code that i know is 100% the same
- So my hypothesis was right, it only seems to throw that error when the functions are different. now to really
test that I will now make the chill and the expected actions be the exact same thing
- now I have a better understanding about why it was throwing that error, for the moment is seems that it was
throwing that error because either the return value was not the correct type or because the functions were not
the same.
- I think that the return value must not be correct because jest is used by Facebook and i doubt that they would
throw this weird error for something as simple as the functions don't match.
- now I am going to have to add the actions information back line by line to test and see where it trips up.
not the most effective but It will work.


------------------------------------MODULAR CODE----------------------------------------------------------------------
- the genral idea is to encapsulate the private data througha wrapper function
- the basic pattern and the one I am going to probably use is the module pattern
- the module pattern can be done through an iife
